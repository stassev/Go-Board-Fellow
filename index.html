<!-- 
#Copyright (C) Svetlin Tassev

# This file is part of Go Board Fellow

# Go Board Fellow is free software: you can redistribute it and/or modify it under 
# the terms of the GNU General Public License as published by the Free Software 
# Foundation, either version 3 of the License, or (at your option) any later version

# Go Board Fellow is distributed in the hope that it will be useful, but WITHOUT 
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details

# You should have received a copy of the GNU General Public License along 
# with Go Board Fellow. If not, see <https://www.gnu.org/licenses/>.

 -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Go Board Fellow</title>
    <style>
        canvas {
            border: 1px solid black;
        }

        #controls {
            /*padding: 2px; No background or border, just your original padding */

            display: flex;
            flex-wrap: wrap;
            /*
            gap: 2px;
            margin-top: 5px;*/
            align-items: center;
            justify-content: flex-start;

        }

        #controls label,
        #controls button {
            border: 1.5px solid #222;

            /*padding: 1px 5px;
            font-family: 'Segoe UI', 'Arial', sans-serif;
            font-size: 1rem;
            
            margin: 0;
            border-radius: 5px;*/
            cursor: pointer;
            transition: background 0.2s, color 0.2s, opacity 0.2s;
            font-size: 11pt;
            padding: 2pt;
            box-shadow: 0 2px 2px rgba(60, 60, 60, 0.08);
        }

        #controls label {
            background: #19b5fe;
            font-size: 11pt;
            padding: 2pt;
            /* Bolder blue-cyan */
            color: #fff;
        }

        #cameraButton {
            font-size: 11pt;
            padding: 2pt;
            background: #3c40c6;
            /* Bolder blue */
            color: #fff;
        }

        #snapButton {
            font-size: 11pt;
            padding: 2pt;
            background: #8854d0;
            /* Bolder purple */
            color: #fff;
        }

        #voiceButton {
            font-size: 11pt;
            padding: 2pt;
            background: #f53b57;
            /* Bolder pink-red */
            color: #fff;
        }

        #caibrateColorsButton {
            font-size: 11pt;
            padding: 2pt;
            background: #0be881;
            /* Bolder green */
            color: #222;
        }

        #processButton {
            font-size: 11pt;
            padding: 2pt;
            background: #f7b731;
            /* Bolder yellow */
            color: #222;
        }

        #downloadButton {
            font-size: 11pt;
            padding: 2pt;
            background: #5758bb;
            /* Bolder indigo */
            color: #fff;
        }

        #controls label:hover,
        #controls button:hover:not(:disabled) {
            filter: brightness(0.92);
            box-shadow: 0 4px 16px rgba(60, 60, 60, 0.14);
        }

        /* Disabled state for buttons and label */
        #controls button:disabled,
        #controls label[aria-disabled="true"] {
            background: #e0e0e0 !important;
            color: #a0a0a0 !important;
            border-color: #cccccc !important;
            cursor: not-allowed;
            opacity: 0.7;
            box-shadow: none;
        }

        .divider {
            display: inline-block;
            width: 1px;
            height: 1.5em;
            background: #bbb;
            margin: 0 6px;
            vertical-align: middle;
        }
    </style>
</head>

<body>
    <h1>Go Board Fellow</h1>
    <h2>Set up</h2>

    <div> 1. Board Size:
        <input type="number" style="width: 4ch;" id="board-size" name="board-size" min="3" max="19" value="19">
        <label for="player-select">Computer plays</label>
        <select id="player-select" name="player">
            <option value="black">Black</option>
            <option value="white">White</option>
        </select>
        at
        <select id="strength">
            <option value="1">Level 1 (Weakest)</option>
            <option value="2">Level 2</option>
            <option value="3">Level 3</option>
            <option value="4">Level 4</option>
            <option value="5">Level 5</option>
            <option value="6">Level 6</option>
            <option value="7">Level 7</option>
            <option value="8">Level 8</option>
            <option value="9">Level 9</option>
            <option value="10" selected>Level 10 (Strongest)</option>
        </select>
    </div>
    <div>2. Place some white and black stones on the board before capturing image. Necessary for calibration. </div>
    <div id="controls">
        3.&nbsp; <input style="display:none;" type="file" id="imageUpload" accept="image/*">
        <label for="imageUpload" style="user-select: none;">
            Load Image
        </label>&nbsp;&nbsp;or&nbsp; choose &nbsp;
        <select id="cameraSelect"></select>
        &nbsp; and &nbsp;
        <button id="cameraButton">Take Photo</button>
        <!--span class="divider"></span-->
    </div>
    <div>
        4. Select 4 corners of grid but beware of perspective distortions when stones are on board. Keep grid aligned with stone centers not grid itself.
    </div>
    <div>
        5. <button id="caibrateColorsButton">Calibrate colors</button><label style="margin-left:8px;">
            <input type="checkbox" id="autoCalibrateCheckbox" checked>
            Automatic calibration?
        </label>
    </div>
    <div>
        6. Start GnuGo or KataGo backend using python scripts. See Readme.
    </div>
    <h2>Generate next move: <button id="voiceButton">Activate ðŸŽ¤ and say "Next" (triggers camera capture)</button> or
        <button id="processButton" disabled>Press this button</button>
    </h2>
    <h2>Save game state: <button id="downloadButton" disabled>Download SGF</button></h2>


    <div>

        <video id="video" width="320" height="240" autoplay playsinline style="transform: scaleX(1);display:none;"></video>
        <button id="snapButton" style="display:none;">Capture</button>
    </div>
    <h2>Next move: <span id="nextMove"></span></h2>
    <canvas id="canvas" width="800" height="800"></canvas>


    <script src="homography.js"></script>
    <script>
        var lastclick = 3;
        var clickStage = lastclick; // 0: waiting for white, 1: waiting for black, 2: done
        let calibrateManual = !document.getElementById('autoCalibrateCheckbox').checked;

        // Listen for changes to the checkbox
        document.getElementById('autoCalibrateCheckbox').addEventListener('change', function() {
            calibrateManual = !this.checked;
            // Optionally, you can log or use calibrateManual here
        });

        function rgb2lab([r, g, b]) {
            // sRGB to XYZ
            function pivotRgb(c) {
                c = c / 255;
                return c > 0.04045 ?
                    Math.pow((c + 0.055) / 1.055, 2.4) :
                    c / 12.92;
            }
            r = pivotRgb(r) * 100;
            g = pivotRgb(g) * 100;
            b = pivotRgb(b) * 100;

            // Observer = 2Â°, Illuminant = D65
            const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
            const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
            const z = r * 0.0193 + g * 0.1192 + b * 0.9505;

            // XYZ to Lab
            function pivotXyz(n) {
                return n > 0.008856 ?
                    Math.pow(n, 1 / 3) :
                    (7.787 * n) + 16 / 116;
            }
            const refX = 95.047,
                refY = 100.0,
                refZ = 108.883;
            const fx = pivotXyz(x / refX);
            const fy = pivotXyz(y / refY);
            const fz = pivotXyz(z / refZ);

            const L = (116 * fy) - 16;
            const a = 500 * (fx - fy);
            const bVal = 200 * (fy - fz);

            return [L, a, bVal];
        }
        var H;
        let strength = document.getElementById('strength').value;

        document.getElementById('strength').addEventListener('change', function() {
            strength = this.value;
            console.log('Strength updated to:', strength);
            // You can do other things here, like update the UI or preview the strength
        });
        var Player = document.getElementById('player-select').value;

        // If you want to update Player when the selection changes:
        document.getElementById('player-select').addEventListener('change', function() {
            Player = this.value;
            // You can now use Player ('black' or 'white') in your code
            console.log("Selected Player:", Player);
        });
        var centers = [];
        let stream = null;
        var boardSize = parseInt(document.getElementById('board-size').value, 10);

        // Listen for changes
        document.getElementById('board-size').addEventListener('change', function() {
            boardSize = parseInt(this.value, 10);
            // Now you can use boardSize in your code
            console.log("Board Size set to:", boardSize);
        });
        let image = new Image();
        let imageData, transformedData;
        let clickPoints = []; //A19, T19, T1, A1
        let boardState = {};
        let blurRadius;
        const processButton = document.getElementById('processButton');
        var pointRadius = 5;

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        //let recognition = true;
        var recognition;
        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.continuous = true; // keep listening
            recognition.lang = 'en-US'; // or your preferred language
            recognition.interimResults = false; // only act on final results
        } else {
            alert('Speech recognition not supported in this browser.');
        }

        if (recognition) {
            recognition.onresult = function(event) {
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        const transcript = event.results[i][0].transcript.trim().toLowerCase();
                        console.log('Heard:', transcript);
                        if (transcript === "next") {
                            // Trigger the snapButton logic
                            if (!stream) {
                                cameraButton.click();
                            }

                            setTimeout(() => {
                                snapButton.click();
                                setTimeout(() => {
                                    processButton.disabled = false;
                                    processButton.click();
                                }, 0)
                            }, 0)
                        }
                    }
                }
            };
            recognition.stop();
        }
        let isListening = false;
        recognition.onend = function() {
            if (isListening) {
                // Restart recognition if it stopped unexpectedly
                recognition.start();
            }
        };
        const voiceButton = document.getElementById('voiceButton');

        voiceButton.addEventListener('click', () => {
            if (!isListening) {
                isListening = true;
                recognition.start();
                voiceButton.textContent = "ðŸ›‘ Stop Listening";
            } else {
                isListening = false;
                recognition.stop();
                voiceButton.textContent = "ðŸŽ¤ Start Listening";
            }
        });
        recognition.onerror = function(event) {
            console.error('Speech recognition error:', event.error);
            // Optionally restart unless stopped by user
            if (isListening) {
                recognition.stop();
                setTimeout(() => {
                    recognition.start();
                }, 0);

            }
        };
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const imageUpload = document.getElementById('imageUpload');
        const downloadButton = document.getElementById('downloadButton');
        const caibrateColorsButton = document.getElementById('caibrateColorsButton');


        //const processedImage = document.getElementById('processedImage');



        function getColorAt(imgData, x, y) {
            const i = (Math.floor(y) * imgData.width + Math.floor(x)) * 4;
            return [imgData.data[i], imgData.data[i + 1], imgData.data[i + 2]];
        }

        function colorDistance(c1, c2) {
            return Math.sqrt(
                (c1[0] - c2[0]) ** 2 +
                (c1[1] - c2[1]) ** 2 +
                (c1[2] - c2[2]) ** 2
            );
        }

        function kMeansCluster(pixels, k = 4, iterations = 100) {
            // 1. Compute brightness sums
            const a = pixels.map(p => p[0]);
            const minA = a.reduce((min, val) => Math.min(min, val), Infinity);
            const maxA = a.reduce((max, val) => Math.max(max, val), -Infinity);
            const i_min = a.indexOf(minA);
            const i_max = a.indexOf(maxA);
            let midValue = (minA + maxA) / 3;
            let i_mid1 = 0
            let minDiff = Infinity;
            for (let i = 0; i < a.length; i++) {
                const diff = Math.abs(a[i] - midValue);
                if (diff < minDiff && i !== i_min && i !== i_max) {
                    minDiff = diff;
                    i_mid1 = i;
                }
            }
            midValue = (minA + maxA) * 2 / 3;
            i_mid2 = 0
            minDiff = Infinity;
            for (let i = 0; i < a.length; i++) {
                const diff = Math.abs(a[i] - midValue);
                if (diff < minDiff && i !== i_min && i !== i_max) {
                    minDiff = diff;
                    i_mid2 = i;
                }
            }
            let centers = [pixels[i_min], pixels[i_mid1], pixels[i_mid2], pixels[i_max]];

            let labels = new Array(pixels.length);
            for (let iter = 0; iter < iterations; iter++) {
                // Assignment
                for (let i = 0; i < pixels.length; i++) {
                    let minDist = Infinity,
                        bestCenter = 0;
                    for (let j = 0; j < k; j++) {
                        let dist = colorDistance(pixels[i], centers[j]);
                        if (dist < minDist) {
                            minDist = dist;
                            bestCenter = j;
                        }
                    }
                    labels[i] = bestCenter;
                }
                // Update
                let newCenters = Array(k).fill(0).map(() => [0, 0, 0, 0]);
                for (let i = 0; i < pixels.length; i++) {
                    let label = labels[i];
                    newCenters[label][0] += pixels[i][0];
                    newCenters[label][1] += pixels[i][1];
                    newCenters[label][2] += pixels[i][2];
                    newCenters[label][3]++;
                }
                for (let j = 0; j < k; j++) {
                    if (newCenters[j][3] > 0) {
                        centers[j] = [
                            newCenters[j][0] / newCenters[j][3],
                            newCenters[j][1] / newCenters[j][3],
                            newCenters[j][2] / newCenters[j][3]
                        ];
                    }
                }
            }
            return centers;
        }


        function classifyStone(color, centers) {
            let dists = centers.map(c => colorDistance(color, c));
            let minIndex = dists.indexOf(Math.min(...dists));
            return minIndex;
        }
        var white, black;
        // Global variables for previous board and SGF
        let prevBoard = null;

        function boardToKeySet(board) {
            return new Set(Object.keys(board));
        }

        // Helper to deep copy a board object
        function cloneBoard(board) {
            return JSON.parse(JSON.stringify(board));
        }

        // Helper to get neighbors of a position
        function getNeighbors(x, y, size) {
            const neighbors = [];
            if (x > 0) neighbors.push([x - 1, y]);
            if (x < size - 1) neighbors.push([x + 1, y]);
            if (y > 0) neighbors.push([x, y - 1]);
            if (y < size - 1) neighbors.push([x, y + 1]);
            return neighbors;
        }

        // Helper to check if a group has liberties
        function hasLiberty(board, x, y, color, size, visited = new Set()) {
            const key = `${x},${y}`;
            //if (visited.has(key)) return false;
            visited.add(key);
            //console.log(JSON.stringify(visited))
            //console.log(JSON.stringify(board))
            for (const [nx, ny] of getNeighbors(x, y, size)) {
                const nkey = `${nx},${ny}`;
                if (board[nkey] == undefined) return true; // Found a liberty
                if (board[nkey] === color && !visited.has(nkey)) {
                    if (hasLiberty(board, nx, ny, color, size, visited)) return true;
                }
            }
            return false;
        }
        var sgf = '';
        //var prevSgf = '';
        // Main function
        function updateSGF(board) {
            if (!prevBoard) {
                // First call, initialize SGF
                //prevSgf = sgf;
                sgf = createSGF(board);
                prevBoard = cloneBoard(board);
                console.warn("New SGF created: starting new game.");
                return sgf;
            }
            // Find differences
            const prevKeys = boardToKeySet(prevBoard);
            const currKeys = boardToKeySet(board);
            const overlappingKeys = [...prevKeys].filter(k => currKeys.has(k));

            // Check that the values of overlapping keys are the same
            let allMatch = true;
            for (const key of overlappingKeys) {
                if (board[key] !== prevBoard[key]) {
                    //console.warn(`Value mismatch at key ${key}: board=${board[key]}, prevBoard=${prevBoard[key]}`);
                    allMatch = false;
                    break
                }
            }
            if (!allMatch) {
                // First call, initialize SGF
                sgf = createSGF(board);
                prevBoard = cloneBoard(board);
                console.warn("New SGF created: starting new game.");
                return sgf;
            }



            const added = [...currKeys].filter(k => !prevKeys.has(k));
            const removed = [...prevKeys].filter(k => !currKeys.has(k));

            if ((added.length == 0) && (removed.length == 0))
                return sgf

            // Only allow 1 stone added
            if (added.length !== 1) {
                const shouldCreateNewSGF = window.confirm(
                    "Invalid move: More than one stone added or removed.\nDo you want to create a new SGF? Or maybe check calibration."
                );
                if (shouldCreateNewSGF) {
                    //prevSgf = sgf;
                    sgf = createSGF(board);
                    prevBoard = cloneBoard(board);
                    console.warn("New SGF created.");
                    return sgf;
                } else {
                    //prevSgf = sgf;
                    boardState = cloneBoard(prevBoard);
                    console.warn("SGF creation cancelled by user.");
                    return sgf;
                }
            }

            // Check for valid captures
            let validCapture = true;
            if (removed.length > 0) {
                // All removed stones must be of the opposite color and must be captured by the new stone
                //const [ax, ay] = added[0].split(',').map(Number);
                const newStoneColor = board[added[0]];
                const oppColor = newStoneColor === black ? white : black;

                // Simulate the board before the move
                let testBoard = cloneBoard(prevBoard);
                testBoard[added[0]] = newStoneColor;

                // Collect all captured stones
                let actuallyCaptured = [];
                for (const rem of removed) {
                    const [rx, ry] = rem.split(',').map(Number);
                    if (prevBoard[rem] !== oppColor) {
                        validCapture = false;
                        break;
                    }
                    // Check if this group has no liberties after the move
                    if (!hasLiberty(testBoard, rx, ry, oppColor, boardSize)) {
                        actuallyCaptured.push(rem);
                    }
                }
                // All removed stones must have been captured
                if (actuallyCaptured.length !== removed.length) validCapture = false;
            }

            if (!validCapture) {
                const shouldCreateNewSGF = window.confirm(
                    "Invalid capture detected.\nDo you want to create a new SGF? Or maybe check calibration."
                );
                if (shouldCreateNewSGF) {
                    sgf = createSGF(board);
                    prevBoard = cloneBoard(board);
                    console.warn("New SGF created.");
                    return sgf;
                } else {
                    boardState = cloneBoard(prevBoard);

                    console.warn("SGF creation cancelled by user.");
                    return sgf;
                }
            }

            // Valid move, update SGF with the move
            const [x, y] = added[0].split(',').map(Number);
            const coord = String.fromCharCode(97 + x) + String.fromCharCode(97 + y);
            let move = board[added[0]] === black ? `;B[${coord}]` : `;W[${coord}]`;
            // Remove trailing ')' and add the move
            sgf = sgf.replace(/\)\s*$/, '') + move + ')';
            prevBoard = cloneBoard(board);
            return sgf;
        }

        // Your original createSGF function for reference
        function createSGF(board) {
            let sgf = "(;GM[1]FF[4]SZ[" + boardSize.toString() + "]\n";
            for (let key in board) {
                let [x, y] = key.split(',').map(Number);
                let coord = String.fromCharCode(97 + x) + String.fromCharCode(97 + y);
                if (board[key] === black) {
                    sgf += `AB[${coord}]\n`;
                } else if (board[key] === white) {
                    sgf += `AW[${coord}]\n`;
                }
            }
            sgf += ")";
            return sgf;
        }
        // = Math.max(image.width, image.height) / 600;

        function updateBoardWithTurn(board, x, y, color, size) {
            const key = `${x},${y}`;
            // Place the stone
            prevBoard = cloneBoard(board);
            board[key] = color;
            const oppColor = (color === black) ? white : black;
            let toRemove = new Set();

            // Check neighbors for captures
            for (const [nx, ny] of getNeighbors(x, y, size)) {
                const nkey = `${nx},${ny}`;
                if (board[nkey] === oppColor) {
                    // If neighbor group has no liberties after this move, mark all stones in the group for removal
                    let visited = new Set();
                    if (!hasLiberty(board, nx, ny, oppColor, size, visited)) {
                        // Remove all stones in this group
                        for (const stone of visited) {
                            toRemove.add(stone);
                        }
                    }
                }
            }

            // Remove captured stones
            for (const rem of toRemove) {
                delete board[rem];
            }

            // Check for suicide (if the placed stone/group has no liberties)
            let visited = new Set();
            if (!hasLiberty(board, x, y, color, size, visited)) {
                // Suicide: remove the stone/group just placed
                for (const stone of visited) {
                    delete board[stone];
                }
            }

            // Update SGF
            sgf = updateSGF(board);
            prevBoard = cloneBoard(board);
            return sgf;
        }

        imageUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (evt) => {
                    image.onload = () => {
                        canvas.width = image.width;
                        canvas.height = image.height;
                        //blurRadius = Math.max(image.width, image.height) / 200;

                        // Calculate blur radius as image size / 100 (use the larger of width or height)


                        // Set the blur filter
                        //  ctx.filter = `blur(${blurRadius}px)`;

                        //ctx.drawImage(image, 0, 0);

                        processButton.disabled = false;
                        redrawAll();
                    };
                    image.src = evt.target.result;
                };
                reader.readAsDataURL(file);
            }
        });
        const cameraButton = document.getElementById('cameraButton');
        const video = document.getElementById('video');
        const snapButton = document.getElementById('snapButton');
        //const canvas = document.getElementById('canvas');
        //const ctx = canvas.getContext('2d');


        // Helper: Disable camera controls
        function disableCameraControls() {
            cameraSelect.disabled = true;
            cameraButton.disabled = true;
            snapButton.disabled = true;
            processButton.disabled = true;
        }

        // Check and request camera permission
        async function ensureCameraPermission() {
            try {
                // Try to access the camera (minimal constraints)
                stream = await navigator.mediaDevices.getUserMedia({
                    video: true
                });
                // If successful, stop the tracks immediately (we just need permission)
                stream.getTracks().forEach(track => track.stop());
                return true;
            } catch (err) {
                alert('Camera permission denied or not available.');
                disableCameraControls();
                return false;
            }
        }

        // Populate camera select dropdown
        async function populateCameras() {
            const devices = await navigator.mediaDevices.enumerateDevices();
            cameraSelect.innerHTML = '';
            devices
                .filter(device => device.kind === 'videoinput')
                .forEach((device, idx) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.text = device.label || `Camera ${idx + 1}`;
                    cameraSelect.appendChild(option);
                });
        }

        // Initialization
        (async function init() {
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                const hasPermission = await ensureCameraPermission();
                if (hasPermission) {
                    await populateCameras();
                    cameraSelect.disabled = false;
                    cameraButton.disabled = false;
                }
            } else {
                alert('getUserMedia not supported in this browser.');
                disableCameraControls();
            }
        })();

        // Camera button event
        cameraButton.addEventListener('click', async () => {
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                try {
                    if (stream) {
                        stream.getTracks().forEach(track => track.stop());
                    }
                    const deviceId = cameraSelect.value;
                    stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            deviceId: deviceId ? {
                                exact: deviceId
                            } : undefined
                        }
                    });
                    video.srcObject = stream;
                    video.style.display = 'block';
                    video.style.transform = 'scaleX(1)';
                    snapButton.style.display = 'inline-block';
                } catch (err) {
                    alert('Camera access denied or not available.');
                }
            } else {
                alert('getUserMedia not supported in this browser.');
            }
        });

        // Snap button event
        snapButton.addEventListener('click', () => {
            const width = video.videoWidth;
            const height = video.videoHeight;
            canvas.width = width;
            canvas.height = height;
            //const blurRadius = Math.max(width, height) / 200;
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.drawImage(video, 0, 0, width, height);
            ctx.restore();
            ctx.filter = 'none';

            video.style.display = 'none';
            snapButton.style.display = 'none';
            processButton.disabled = false;
            image.src = canvas.toDataURL();
            redrawAll();
        });

        function generateLines(n = boardSize) {
            let lines = [];
            for (let row = 0; row < n; row++) {
                for (let col = 0; col < n; col += n - 1) {
                    lines.push([1 - row / (n - 1), col / (n - 1)]);
                }
            }

            for (let col = 0; col < n; col++) {
                for (let row = 0; row < n; row += n - 1) {
                    lines.push([1 - row / (n - 1), col / (n - 1)]);
                }
            }
            return lines;
        }

        function generateNumberPositions(n = boardSize) {
            let lines = [];
            for (let row = 0; row < n; row++) {
                let col = -1;
                lines.push([1 - (n - 0.7 - row) / (n - 1), col / (n - 1)]);
            }
            return lines;
        }

        function generateLetterPositions(n = boardSize) {
            let lines = [];
            for (let col = 0; col < n; col++) {
                let row = -0.5;
                lines.push([1 - row / (n - 1), (col - 0.1) / (n - 1)]);
            }
            return lines;
        }

        const src = [
            [1, 0],
            [1, 1],
            [0, 1],
            [0, 0]
        ];

        function calculateBlurRadius() {
            function distance(p1, p2) {
                return Math.hypot(p1[0] - p2[0], p1[1] - p2[1]);
            }

            let sides = [
                distance(clickPoints[0], clickPoints[1]),
                distance(clickPoints[1], clickPoints[2]),
                distance(clickPoints[2], clickPoints[3]),
                distance(clickPoints[3], clickPoints[0])
            ];

            let shortest = Math.min(...sides);
            return shortest / 6 / boardSize;
        }

        function drawGrid(clickPoints) {
            const dst = clickPoints; // [[x0, y0], [x1, y1], [x2, y2], [x3, y3]]

            // 3. Compute homography
            H = computeHomography(src, dst);

            let gridLines = generateLines();
            let LinesToDraw = gridLines.map(([u, v]) => applyHomography(H, [u, v]));

            //console.log(LinesToDraw);
            //ctx.save();
            ctx.strokeStyle = 'blue'; // or any color you like
            ctx.lineWidth = 3;

            for (let i = 0; i < LinesToDraw.length; i += 2) {
                const [x1, y1] = LinesToDraw[i];
                const [x2, y2] = LinesToDraw[i + 1];
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
        }

        let draggingPointIndex = null;
        let isDragging = false;
        //const pointRadius = 8; // match your drawing radius

        canvas.addEventListener('click', (e) => {
            if (clickPoints.length === 4) {
                //      drawGrid(clickPoints);
                return;
            }
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            clickPoints.push([x, y]);
            ctx.fillStyle = 'rgb(100,100,255)';
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, 2 * Math.PI);
            ctx.fill();
            if (clickPoints.length === 4) {
                blurRadius = calculateBlurRadius();
                pointRadius = blurRadius * 2.;
                //drawGrid(clickPoints);


                redrawAll();
            }

        });

        canvas.addEventListener('mousedown', (e) => {
            if (clickPoints.length < 4) return; // Only allow dragging after 4 points
            if (clickStage < lastclick) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Check if the click is near any point
            for (let i = 0; i < clickPoints.length; i++) {
                const [px, py] = clickPoints[i];
                const dist = Math.hypot(px - x, py - y);
                if (dist < pointRadius + 4) { // allow some tolerance
                    draggingPointIndex = i;
                    isDragging = true;
                    break;
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (clickStage < lastclick) return;
            if (!isDragging || draggingPointIndex === null) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Update the dragged point
            clickPoints[draggingPointIndex] = [x, y];

            // Redraw everything
            redrawAll();
        });

        canvas.addEventListener('mouseup', () => {
            if (clickStage < lastclick) return;
            if (isDragging) {
                isDragging = false;
                draggingPointIndex = null;
                redrawAll();
            }
        });

        function getGoCoordinate(x, y, boardSize) {
            // x: 0-based column index (0 = A, 1 = B, ..., 7 = H, 8 = J, ..., 18 = T)
            // y: 0-based row index (0 = 1, 1 = 2, ..., 18 = 19)
            let letters = [];
            for (let i = 0, code = 65; letters.length < boardSize; code++) {
                let letter = String.fromCharCode(code);
                if (letter !== 'I') letters.push(letter);
            }
            return letters[x] + (y);
        }

        function redrawAll() {
            ctx.drawImage(image, 0, 0);
            // Draw points

            let k = 0;
            // Draw grid if 4 points exist
            if (clickPoints.length === 4) {
                drawGrid(clickPoints);
                blurRadius = calculateBlurRadius();
                pointRadius = blurRadius * 2.;

                let letterPositions = generateLetterPositions().map(([u, v]) => applyHomography(H, [u, v]))
                let numberPositions = generateNumberPositions().map(([u, v]) => applyHomography(H, [u, v]))
                let k = 0;
                for (const [x, y] of letterPositions) {
                    ctx.fillStyle = 'red';
                    ctx.font = '20px Arial';
                    let label = "ABCDEFGHJKLMNOPQRSTUVWXYZ" [k];
                    ctx.fillText(label, x, y);
                    k++;
                }
                k = 0;
                for (const [x, y] of numberPositions) {
                    ctx.fillStyle = 'red';
                    ctx.font = '20px Arial';
                    let label = (k + 1).toString();
                    ctx.fillText(label, x, y);
                    k++;
                }

                for (const [x, y] of clickPoints) {
                    ctx.strokeStyle = 'rgb(100,100,255)'; // Set the contour color
                    ctx.beginPath();
                    ctx.arc(x, y, pointRadius, 0, 2 * Math.PI);
                    ctx.stroke(); // Draw only the outline
                    //let label = getGoCoordinate(boardX[k], boardY[k], boardSize);

                    // Offset the label (e.g., 10px right and 5px down)
                    //ctx.fillStyle = 'rgb(100,100,255)';
                    //ctx.font = '20px Arial';
                    //ctx.fillText(label, x + offset[k][0], y + offset[k][1]);
                    //k++;
                }
            }

        }



        // Generate normalized grid positions for boardSize x boardSize
        function generateGridPositions(n = boardSize) {
            let positions = [];
            for (let row = 0; row < n; row++) {
                for (let col = 0; col < n; col++) {
                    positions.push([1 - row / (n - 1), col / (n - 1)]);
                }
            }
            return positions;
        }

        var dst;

        caibrateColorsButton.addEventListener('click', () => {
            if (clickPoints.length != 4) {
                alert('Please click exactly 4 corners of the Go board.');
                return;
            }
            dst = clickPoints; // [[x0, y0], [x1, y1], [x2, y2], [x3, y3]]


            ctx.filter = `blur(${blurRadius}px)`;
            ctx.drawImage(image, 0, 0);
            setTimeout(() => {
                const H = computeHomography(src, dst);

                //ctx.restore();

                // 4. Generate normalized grid positions
                const gridFinePositions = generateGridPositions(n = 256);

                // 5. Map normalized grid to image coordinates
                const warpedFineGrid = gridFinePositions.map(([u, v]) => applyHomography(H, [u, v]));
                imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                console.log('Calibrating colors:')
                const colors = warpedFineGrid.map(([x, y]) => getColorAt(imageData, x, y)).map(rgb2lab);
                //const labStrings = colors.map(([L, a, b]) => `${L},${a*20},${b*20}`);

                //// Save as a .txt or .csv file in the browser
                //function saveStrings(list, filename, extension = 'txt') {
                //  const blob = new Blob([list.join('\n')], { type: 'text/plain' });
                //  const a = document.createElement('a');
                //  a.href = URL.createObjectURL(blob);
                //  a.download = `${filename}.${extension}`;
                //  a.click();
                //}
                //
                //saveStrings(labStrings, 'lab_colors1', 'csv');
                centers = kMeansCluster(colors);

                function norm(xx) {
                    return xx[0]
                }
                let mag = [norm(centers[0]), norm(centers[1]), norm(centers[2]), norm(centers[3])]
                black = mag.indexOf(Math.min(...mag));
                white = mag.indexOf(Math.max(...mag));

                if (calibrateManual) {
                    clickStage = 0;

                    let selectedLAB = [];

                    function handleCanvasClick(event) {
                        if (clickStage > lastclick) return; // Only process two clicks

                        // Get click coordinates relative to the canvas
                        const rect = canvas.getBoundingClientRect();
                        const x = Math.round(event.clientX - rect.left);
                        const y = Math.round(event.clientY - rect.top);

                        // Extract LAB value at this pixel
                        const rgb = getColorAt(imageData, x, y);
                        const lab = rgb2lab(rgb);
                        selectedLAB.push(lab);

                        if (clickStage === 0) {
                            alert("Now click on the center of a BLACK stone.");
                        }
                        if (clickStage === 1) {
                            alert("Now click brightest part of board.");
                        }
                        if (clickStage === 2) {
                            alert("Now click darkest part of board.");
                        } else if (clickStage === lastclick) {
                            // Overwrite centers after both clicks
                            white = 0;
                            black = 1;

                            centers[white] = selectedLAB[0];
                            centers[black] = selectedLAB[1];
                            centers[2] = selectedLAB[2];
                            centers[3] = selectedLAB[3];
                            //alert("Calibration complete.");
                            setTimeout(() => {

                                ctx.filter = 'none';
                                redrawAll();
                                canvas.removeEventListener('click', handleCanvasClick); // Optional: remove handler
                            }, 0);


                        }
                        clickStage++;
                    }

                    // Start the process
                    alert("Click on the center of a blurred WHITE stone.");
                    canvas.addEventListener('click', handleCanvasClick);
                } else {

                    ctx.filter = 'none';
                    redrawAll();
                }


            }, 0);



        })

        processButton.addEventListener('click', () => {
            document.getElementById('nextMove').textContent = '';
            if (clickPoints.length !== 4) {
                alert('Please click exactly 4 corners of the Go board.');
                return;
            }
            if (centers.length < 3) {
                alert('Please calibrate colors.');
                return;
            }

            dst = clickPoints; // [[x0, y0], [x1, y1], [x2, y2], [x3, y3]]

            // 3. Compute homography
            const H = computeHomography(src, dst);

            //ctx.restore();

            // 4. Generate normalized grid positions
            const gridPositions = generateGridPositions();
            const gridFinePositions = generateGridPositions(n = boardSize * 10);

            // 5. Map normalized grid to image coordinates
            const warpedGrid = gridPositions.map(([u, v]) => applyHomography(H, [u, v]));
            const warpedFineGrid = gridFinePositions.map(([u, v]) => applyHomography(H, [u, v]));

            //console.log(clickPoints);
            //console.log(warpedGrid)
            ctx.filter = `blur(${blurRadius}px)`;

            ctx.drawImage(image, 0, 0);

            setTimeout(() => {

                imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                //   const { centers } = kMeansCluster(imageData);

                //console.log('c',colors,imageData)
                // 2. Run kMeansCluster on these colors

                //if (centers.length != 3) {
                //    console.log('Calibrating colors:', centers)
                //    const colors = warpedFineGrid.map(([x, y]) => getColorAt(imageData, x, y)).map(rgb2lab);;
                //    centers = kMeansCluster(colors);
                //}


                //console.log(centers,black,white)
                boardState = {};
                warpedGrid.forEach(([x, y], i) => {
                    const color = rgb2lab(getColorAt(imageData, x, y));
                    const label = classifyStone(color, centers);
                    const col = i % boardSize;
                    const row = Math.floor(i / boardSize);
                    if (label === black || label === white) {
                        boardState[`${col},${row}`] = label;

                    }
                });



                ctx.filter = 'none';

                redrawAll();
                warpedGrid.forEach(([x, y], i) => {
                    const col = i % boardSize;
                    const row = Math.floor(i / boardSize);
                    let label = boardState[`${col},${row}`];
                    if (label === black || label === white) {
                        ctx.beginPath();
                        ctx.arc(x, y, pointRadius / 1.2, 0, 2 * Math.PI);
                        ctx.fillStyle = label === black ? 'red' : 'green';
                        ctx.fill();
                        //ctx.filter = `blur(${blurRadius}px)`;
                    }
                });

                downloadButton.disabled = false;
                sgf = updateSGF(boardState);
                fetch('http://localhost:5000/next-move', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            sgf,
                            color: Player, // Add this line to specify the color to play
                            strength: strength // Add this line,

                        })
                    })
                    .then(response => response.json())
                    .then(data => {
                        const nextMove = data.move.slice(2).trim();
                        // Print the next move to the HTML
                        document.getElementById('nextMove').textContent = nextMove;
                        if (nextMove) {
                            //console.log('nm ',nextMove)
                            // Split into letter and number
                            if (nextMove === "resign") {
                                const resignAudio = new Audio(`audio/resign.wav`);
                                resignAudio.play();
                            }
                            if (nextMove === "PASS") {
                                const passAudio = new Audio(`audio/pass.wav`);
                                passAudio.play();
                            }
                            const match = nextMove.match(/^([A-Za-z])\s?(\d{1,2})$/);
                            //console.log(match)
                            if (match) {
                                const letter = match[1].toLowerCase(); // e.g., 'k'
                                const number = match[2]; // e.g., '10'
                                //console.log('audio',letter,number,`audio/${letter}.wav`,`audio/${number}.wav`)
                                // Create audio elements for the letter and number
                                const letterAudio = new Audio(`audio/${letter}.wav`);
                                const numberAudio = new Audio(`audio/${number}.wav`);

                                // Play letter, then number
                                letterAudio.onended = () => numberAudio.play();
                                letterAudio.play();
                                //console.log('sh')
                                function letterToCol(letter, boardSize) {
                                    // Create array of valid letters (skip 'i')
                                    let letters = [];
                                    for (let i = 0, code = 97; letters.length < boardSize; code++) { // 97 is 'a'
                                        let l = String.fromCharCode(code);
                                        if (l !== 'i') letters.push(l);
                                    }
                                    return letters.indexOf(letter.toLowerCase());
                                }

                                function goCoordsToIndices(letter, number, boardSize) {
                                    let col = letterToCol(letter, boardSize);
                                    let row = boardSize - parseInt(number); // 0 at bottom, boardSize-1 at top
                                    return [row, col];
                                }

                                // Example usage:
                                let [row, col] = goCoordsToIndices(letter, number, boardSize);

                                // Now compute normalized board coordinates:
                                let u = 1 - row / (boardSize - 1);
                                let v = col / (boardSize - 1);
                                let [x, y] = applyHomography(H, [u, v]);

                                ctx.beginPath();
                                ctx.arc(x, y, pointRadius * 1.7, 0, 2 * Math.PI);
                                ctx.fillStyle = 'yellow';
                                ctx.fill();
                                setTimeout(() => {
                                    updateBoardWithTurn(boardState, col, row, (Player === "Black" ? black : white), boardSize);
                                }, 0)
                            }
                        }
                    })
                    .catch(error => {
                        document.getElementById('nextMove').textContent = "Error: " + error;
                    });
            }, 0);

        });

        downloadButton.addEventListener('click', () => {

            //const sgf = updateSGF(boardState);
            const blob = new Blob([sgf], {
                type: 'text/plain'
            });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'board.sgf';
            link.click();
        });
    </script>
</body>

</html>